=head1 How to write a plugin 

Dancer is a DSL for writing web applications. It's focused on
providing the obvious and the feature set is limited on purpose.

For advanced or particular needs, Dancer's DSL can be extended by plugins.

This article will explain the basics and concepts of Dancer plugins
and will guide you through the writing of your first plugin:
C<Dancer::Plugin::MobileDevice>.

=head2 The Basics

Before starting writing our own plugin, let's explain what a plugin
can do, and how.

A plugin is a package that declares (with the C<register> keyword) a set of I<keywords> that are
bound to I<code refs>. When a plugin has performed all of its declarations,
it registers itself to Dancer's core with the C<register_plugin>
keyword.

Once a Dancer application imports a plugin, all of the keywords
declared by the plugin are visible in the application's namespace,
just as if they were part of Dancer's core DSL.

A plugin can also do all that a regular Dancer application can, like
declaring a C<before> filter, declaring a couple of route handlers or
even doing some Perl code at its import time.

=head2 The concept of a "mobile" plugin

Now that we know what a Dancer plugin is, and how it works, we have to
find someting to do. I recently had the idea to implement a plugin that
would provide the developer with a facility to detect if the user agent
is a mobile device or not.

When thinking at that idea, I realized it would be a perfect support for
an article, because the plugin itself will not be complicated while using an
interesting subsets of the possibilities.

The idea is to provide the following features:

=over 4

=item * dynamic layout

We want to serve a light HTML content when accessed by a mobile
device, so we'll basically set a specific layout whenever a mobile
client requests a page. That way, we can forgert about the layout and
focus on our route handlers, and the plugin will hanlde that for us.

=item * boolean accessor C<is_mobile_device>

Basically, the plugin should provide an accessor for letting the
developer know if the current user agent is a mobile device or not.

=item * default token in templates

We want all of our template calls to be able to know of
C<is_mobile_device>, so we want to make it a defaut tokens.

=back

OK, I think this feature-set sounds to be a good start for
C<Dancer::Plugin::MobileDevice>, let's start writing it!

=head2 Writing the plugin

To start with, let's start with an empty plugin skeleton:

    package Dancer::Plugin::MobileDevice;
    use Dancer ':syntax';
    use Dancer::Plugin;

    register_plugin;

That's it, we have an empty plugin. It does nothing yet, except
registering itself to Dancer's core.
We can now add a I<keyword> wich will be exported to our caller's
namespace (basically, the user's application that C<use> our plugin).

=head3 Adding a keyword: C<is_mobile_device>

We want to provide a helper that returns a boolean value telling if
the requesting user agent is mobile device or not, we'll do that by
exporting a new keyword to Dancer's DSL.

This keyword is basically a sub bound to a name (Dancer::Plugin takes
care of the exporting magic for us, we only have to declare new
keywords with 'register' and register the plugin itslef when done with
'register_plugin'.

The sub bound to our C<is_mobile_device> keyword should do one simple
thing: test the user agent string of the incoming request against a
pattern of known mobile devices. This is as easy as the following:

    register 'is_mobile_device' => sub {
        return request->user_agent =~
            /(iPhone|Android|BlackBerry|Mobile|Palm)/
          ? 1 : 0;
    };

That's it. The C<request> keyword is Dancer-native and returns a
L<Dancer::Request> object representing the current incoming request.
It provides among other goodies an accessor to the user agent string
(C<user_agent>) and we test it with a regular expression with famous
mobile device strings.

Whenever it's called from a route handler (or a filter), it returns
true or false depending on the match.

=head3 Dynamic layout

We now want to change the layout whenver a request is served for a
mobile device. This will be done easily with a before filter:

    before sub {
        var orig_layout => setting('layout');

        if (is_mobile_device()) {
            setting layout => 'mobile';
        }
    };

A C<before> filter is executed whenever a request is served, I<before>
the route handler. This filter takes care to change the C<layout>
setting whenever the is_mobile_device is true.

We don't want the layout setting to remain that way afterwards, we
want to restore that setting to its original value after the request
is processed. That's why we save it first with the C<var> keyword.

Then, with an after filter, will reset it to its original value:

    after sub {
        my $orig_layout = vars->{'orig_layout'};
        setting layout => $orig_layout;
    };

That way, if a non-mobilde client comes just after a mobile one, the
layout will be back to its original value.

=head3 Default token

Finally, we want our templates to be able to render specific content
for mobile devices, so we want to provide all our templates wih a
C<is_mobile_device> token, whose value will be obviously given by the
helper previously defined.

This is easy to do, we just have to write a C<before_template> filter,
which will alter the default tokens hash table that is given to any
C<template> call.

    before_template sub {
        my $tokens = shift;
        $tokens->{'is_mobile_device'} = is_mobile_device();
    };

That's it, we can now do this kind of switchs in our views:

    <% if is_mobile_device %>
    Some content for mobidle devices
    <% end %>

=head2 Testing our plugin

Writing a plugin for the Dancer ecosystem is a great thing to do.
That's a very good way to contribute to the project. But writing the
plugin is not enough, you should write tests to validate your plugin
before releasing it to the CPAN.

We will now look at how easy it is to do, we'll write a test suite to
make sure evrything provided by the plugin works as expected. Remeber
that tests are still code, take quality seriously and your software
will be better.

=head3 The C<is_mobile_device> keyword

Let's start by testing that our helper works as expected, with
Dancer::Test this is easy to do:

    # t/01-is_mobile_device.t
    use strict;
    use warnings;
    use Test::More import => ['!pass'];

First, note that we ask Test::More not to import the pass keyword,
it's already exported by Dancer and we don't want our test script to
produce a warning.

First of all, we need a basic app that uses our plugin, we'll define
it within the test script, inside a lexical block:

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            return is_mobile_device;
        };
    }

OK, we have a basic app that just loads the plugin and define one
route handler which only returns the value of C<is_mobile_device>.
That's enough, we can now write the tests.


    use Dancer::Test;

Dancer::Test provides a complete set of test functions specialized for
testing a Dancer application. Here we'll use the function
C<response_content_is> which takes a request object (basically an
array with a methoid and a path) and a value, and makes sure the route
handler returns a response that is the same as the expected value.

We'll define a bunc of user agent strings we consider "mobile devices"
and make sure the flag is set appropriately for them:

    my @mobile_devices = qw(Android iPhone PalmOS);
    for my $md (@mobile_devices) {
        $ENV{HTTP_USER_AGENT} = $md;
        response_content_is [GET => '/'], 1, "agent $md is a mobile device";
    }

And we'll add finaly one of this test with a non-mobile string:

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 0, "Mozilla is not a mobile device";

Fine, let's run the test:

    $ perl -Ilib t/01-is_mobile_device.t
    1..4
    ok 1 - agent iPhone is a mobile device
    ok 2 - agent Android is a mobile device
    ok 3 - agent PalmOS is a mobile device
    ok 4 - Mozilla is not a mobile device

Great! We know now for sure that is_mobile_device works, that's a good
start!

=head3 The default template token

We now want to make sure all of our template calls got the
C<is_mobile_device> token, to do that. Our test application will now
only provide a route handler that calls C<template>. Obviously, for
this to work we need ... a template to process. Dancer::Test takes
care for us to initialize the views directory to t/views, so we can
provide our test script with some views without polluting the root
directory of our distribution.

So we first create a view:

    $ mkdir t/views
    $ echo "is_mobile_device: <% is_mobile_device %>" > t/views/index.tt

The view is very basic, it just shows the interpolation of the
C<is_mobile_device> token. Let's use it in our test script.

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            template 'index', {}, {layout => 0};
        };
    }

Same as previously, we define a route handler that does just what we
need, you'll see that we've given some extra options to the
C<template> keyword in order to disable the layout. Indeed, our plugin
sets autoamtically a layout for mobile clients, and we don't want to
see that for the moment.

The second argument given to C<template> is an empty hash which is
actually the tokens hash. It should have been populated by our plugin
under the hood and we'll make sure of that.

    use Dancer::Test;

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_is [GET => '/'], 
        "is_mobile_device: 1\n", 
        "token is_mobile_device is present and valid for Android";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 
        "is_mobile_device: 0\n", 
        "token is_mobile_device is present and valid for Mozilla";

Let's run the test to make sure everything's fine:

    $ perl -Ilib t/02-tokens.t
    1..2
    ok 1 - token is_mobile_device is present and valid for Android
    ok 2 - token is_mobile_device is present and valid for Mozilla

Cool, we now have one more thing to test: making sure the layout
changes appropriately, that the job of our last test script.


=head3 The dynamic layout

In this last test we want to be sure the layout is changed to 'mobile'
whenver a mobile device is served, and that the original layout is
reset afterwards (either if it was defined or not).

To do that we'll use the same technique as before, but with this time,
suing the layouts:

    $ mkdir t/views/layouts
    $ echo "mobile:\n<% content %>" > t/views/layout/mobile.tt
    $ echo "main:\n<% content %>" > t/views/layout/main.tt

We now have our layouts waiting for being used in the t/views/layouts
directory, let's use it.

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            template 'index';
        };
    }

Just a basic route handler, like before, but this time, if a layout is
set, we'll use it.

We want first to test the behaviour of the app when no layout is set:

    use Dancer::Test;

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_like [GET => '/'], 
        qr{mobile\nis_mobile_device: 1}ms, 
        "mobile layout is set for mobile agents";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 
        "is_mobile_device: 0\n", 
        "no layout for non-mobile agents";

And then, when a layout is manually set by the user:

    set layout => 'main';

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_like [GET => '/'], 
        qr{mobile\nis_mobile_device: 1}ms, 
        "mobile layout is set for mobile agents";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_like [GET => '/'], 
        qr{main\nis_mobile_device: 0}ms, 
        "main layout for non-mobile agents";

Let's see if everything works:

    $ perl -Ilib t/03-layouts.t
    ok 1 - mobile layout is set for mobile agents
    ok 2 - no layout for non-mobile agents
    ok 3 - mobile layout is set for mobile agents
    ok 4 - main layout for non-mobile agents

Great, everything works as expected!

=head2 Conclusion

Well, here we are, we now have a Dancer plugin that does what we
wanted, writing a mobile-aware dancer app will now be much more
easier.

As you can imagine, I've wrote Dancer::Plugin::MobileDevice and
uploaded it to CPAN, so if you want to study it a bit more, feel free
to grab the tarball.

=head2 Autor

Alexis Sukrieh, C<< <sukria@sukria.net> >>
