=head1 How to write a plugin 

Dancer is a DSL for writing web applications. It's focused on
providing the obvious and the feature set is limited on purpose.

For advanced or particular needs, Dancer's DSL can be extended by plugins.

This article will explain the basics and concepts of Dancer plugins
and will guide you through the writing of your first plugin:
C<Dancer::Plugin::MobileDevice>.

=head2 The Basics

Before starting to write our own plugin, let's explain what a plugin can do,
and how.

A plugin is a package that declares (with the C<register> keyword) a set of
I<keywords> that are bound to I<code refs>. When a plugin has performed all of
its declarations, it registers itself in Dancer's core with the
C<register_plugin> keyword.

Once a Dancer application imports a plugin, all of the keywords declared by the
plugin are visible in the application's namespace, just as if they were part of
Dancer's core DSL.

A plugin can also do everything a regular Dancer application can do, like
declaring a C<before> filter, declaring a couple of route handlers or even
running some Perl code at its import time.

=head2 The concept of a "mobile" plugin

Now that we know what a Dancer plugin is, and how it works, we have to
find someting to do. I recently had the idea to implement a plugin that
would provide the developer with a facility to detect if the user agent
is a mobile device or not.

When thinking of that idea, I realized it would be a perfect subject for
an article, because the plugin itself will not be complicated while using an
interesting subset of the possibilities.

The idea is to provide the following features:

=over 4

=item * dynamic layout

We want to serve a light HTML content when accessed by a mobile
device, so we'll basically set a specific layout whenever a mobile
client requests a page. That way, we can forget about the layout and
focus on our route handlers, and the plugin will handle that for us.

=item * boolean accessor C<is_mobile_device>

Basically, the plugin should provide an accessor for letting the
developer know if the current user agent is a mobile device or not.

=item * default token in templates

We want all of our template calls to be able to know about
C<is_mobile_device>, so we want to make it a default token.

=back

OK, I think this feature-set sounds like a good start for
C<Dancer::Plugin::MobileDevice>, let's start writing it!

=head2 Writing the plugin

Let's start with an empty plugin skeleton:

    package Dancer::Plugin::MobileDevice;
    use Dancer ':syntax';
    use Dancer::Plugin;

    register_plugin;

That's it, we have an empty plugin. It does nothing yet, except
registering itself to Dancer's core.

We can now add a I<keyword> which will be exported to our caller's
namespace (basically, the user's application that C<use> our plugin).

=head3 Adding a keyword: C<is_mobile_device>

We want to provide a helper that returns a boolean value telling if
the requesting user agent is a mobile device or not, we'll do that by
exporting a new keyword to Dancer's DSL.

This keyword is basically a subroutine bound to a name (L<Dancer::Plugin> takes
care of the exporting magic for us, we only have to declare new
keywords with C<register> and register the plugin itself when done with
C<register_plugin>.

The sub bound to our C<is_mobile_device> keyword should do one simple
thing: test the user agent string of the incoming request against a
pattern of known mobile devices. This is as easy as the following:

    register 'is_mobile_device' => sub {
        return request->user_agent =~
            /(iPhone|Android|BlackBerry|Mobile|Palm)/
          ? 1 : 0;
    };

That's it. The C<request> keyword is Dancer-native and returns a
L<Dancer::Request> object representing the current incoming request.
It provides among other goodies an accessor to the user agent string
(C<user_agent>) and we test it with a regular expression with well-known
mobile device strings.

Whenever it's called from a route handler (or a filter), it returns
true or false depending on the match.

=head3 Dynamic layout

We now want to change the layout whenver a request is served for a
mobile device. This can easily be done with a before filter:

    before sub {
        var orig_layout => setting('layout');

        if ( is_mobile_device() ) {
            setting layout => 'mobile';
        }
    };

A C<before> filter is executed whenever a request is served, B<before>
the route handler. This filter takes care of changing the C<layout>
setting whenever the C<is_mobile_device> is true.

We don't want the layout setting to remain that way afterwards, we
want to restore that setting to its original value after the request
is processed. That's why we save it first with the C<var> keyword.

Then, with an after filter, will reset it to its original value:

    after sub {
        my $orig_layout = vars->{'orig_layout'};
        setting layout => $orig_layout;
    };

That way, if a non-mobile client comes just after a mobile one, the
layout will be back to its original value.

=head3 Default token

Finally, we want our templates to be able to render specific content
for mobile devices, so we want to provide all our templates wih a
C<is_mobile_device> token, whose value will be obviously given by the
helper previously defined.

This is easy to do, we just have to write a C<before_template> filter,
which will alter the default tokens hash table that is given to any
C<template> call.

    before_template sub {
        my $tokens = shift;
        $tokens->{'is_mobile_device'} = is_mobile_device();
    };

That's it, we can now do this kind of conditions in our views:

    <% if is_mobile_device %>
        some content for mobile devices
    <% end %>

=head2 Testing our plugin

Writing a plugin for the Dancer ecosystem is a great thing to do; It's a
very good way to contribute to the project, but writing the
plugin is not enough, you should write tests to validate your plugin
before releasing it to the CPAN.

We will now look at how easy it is to do that and we'll write a test suite to
make sure everything provided by the plugin works as expected. Remember
that tests are still code. Take quality seriously and your software
will be better.

=head3 The C<is_mobile_device> keyword

Let's start by testing that our helper works as expected, with
L<Dancer::Test> this is easy to do:

    # t/01-is_mobile_device.t
    use strict;
    use warnings;
    use Test::More import => ['!pass'];

First, note that we ask not to import L<Test::More>'s C<pass> keyword,
it's already exported by Dancer and we don't want our test script to
produce a warning.

First of all, we need a basic app that uses our plugin, we'll define
it within the test script, inside a lexical block:

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            return is_mobile_device;
        };
    }

OK, we have a basic app that just loads the plugin and defines one
route handler which only returns the value of C<is_mobile_device>.
That's enough, we can now write the tests.

    use Dancer::Test;

L<Dancer::Test> provides a complete set of test functions specialized for
testing a Dancer application. Here we'll use the function
C<response_content_is> which takes a request object (basically an
array with a method and a path) and a value, and makes sure the route
handler returns a response that is the same as the expected value.

We'll define a bunch of user agent strings we consider "mobile devices"
and make sure the flag is set appropriately for them:

    my @mobile_devices = qw(Android iPhone PalmOS);

    for my $md (@mobile_devices) {
        $ENV{HTTP_USER_AGENT} = $md;
        response_content_is [GET => '/'], 1, "agent $md is a mobile device";
    }

And we finally add a non-mobile string:

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 0, "Mozilla is not a mobile device";

Let's run the test:

    $ perl -Ilib t/01-is_mobile_device.t
    1..4
    ok 1 - agent iPhone is a mobile device
    ok 2 - agent Android is a mobile device
    ok 3 - agent PalmOS is a mobile device
    ok 4 - Mozilla is not a mobile device

Great! We know now for sure that C<is_mobile_device works>, that's a good
start!

=head3 The default template token

We now want to make sure all of our template calls got the
C<is_mobile_device> token. To do that, our test application will now
only provide a route handler that calls C<template>. Obviously, for
this to work we need ... a template to process. Dancer::Test takes
care for us to initialize the views directory to F<t/views>, so we can
provide our test script with some views without polluting the root
directory of our distribution.

So we first create a view:

    $ mkdir t/views
    $ echo "is_mobile_device: <% is_mobile_device %>" > t/views/index.tt

The view is very basic, it just shows the interpolation of the
C<is_mobile_device> token. Let's use it in our test script.

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            template 'index', {}, { layout => 0 };
        };
    }

Same as previously, we define a route handler that does just what we
need. You'll see that we've given some extra options to the
C<template> keyword in order to disable the layout. Indeed, our plugin
automatically sets a layout for mobile clients, and we don't want to
see that for the moment.

The second argument given to C<template> is an empty hash which is
actually the tokens hash. It should have been populated by our plugin
under the hood and we'll make sure of that.

    use Dancer::Test;

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_is [GET => '/'], 
        "is_mobile_device: 1\n", 
        "token is_mobile_device is present and valid for Android";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 
        "is_mobile_device: 0\n", 
        "token is_mobile_device is present and valid for Mozilla";

Let's run the test to make sure everything's fine:

    $ perl -Ilib t/02-tokens.t
    1..2
    ok 1 - token is_mobile_device is present and valid for Android
    ok 2 - token is_mobile_device is present and valid for Mozilla

Cool! @e now have one more thing to test: making sure the layout
changes appropriately, the job of our last test script.

=head3 The dynamic layout

In this last test we want to be sure the layout is changed to 'mobile'
whenever a mobile device is served, and that the original layout is
reset afterwards (whether it was defined or not).

To do that we'll use the same technique as before, but this time
with the layouts:

    $ mkdir t/views/layouts
    $ echo -e "mobile:\n<% content %>" > t/views/layout/mobile.tt
    $ echo -e "main:\n<% content %>" > t/views/layout/main.tt

I<(or use your favorite editor to create our layout files)>

We now have our layouts waiting to be used in the C<t/views/layouts>
directory, let's use it.

    {
        use Dancer;
        use Dancer::Plugin::MobileDevice;

        get '/' => sub {
            template 'index';
        };
    }

Just a basic route handler, like before, but this time if a layout is
set, we'll use it.

We want first to test the behaviour of the app when no layout is set:

    use Dancer::Test;

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_like [GET => '/'], 
        qr{mobile\nis_mobile_device: 1}ms, 
        "mobile layout is set for mobile agents";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_is [GET => '/'], 
        "is_mobile_device: 0\n", 
        "no layout for non-mobile agents";

And then, when a layout is manually set by the user:

    set layout => 'main';

    $ENV{HTTP_USER_AGENT} = 'Android';
    response_content_like [GET => '/'], 
        qr{mobile\nis_mobile_device: 1}ms, 
        "mobile layout is set for mobile agents";

    $ENV{HTTP_USER_AGENT} = 'Mozilla';
    response_content_like [GET => '/'], 
        qr{main\nis_mobile_device: 0}ms, 
        "main layout for non-mobile agents";

Let's see if everything works:

    $ perl -Ilib t/03-layouts.t
    ok 1 - mobile layout is set for mobile agents
    ok 2 - no layout for non-mobile agents
    ok 3 - mobile layout is set for mobile agents
    ok 4 - main layout for non-mobile agents

Great, everything works as expected!

=head2 Conclusion

Well, here we are, we now have a Dancer plugin that does what we
wanted, writing a mobile-aware dancer app will now be much easier.

As you can imagine, I've written L<Dancer::Plugin::MobileDevice> and
uploaded it to CPAN, so if you want to study it a bit more, feel free
to grab the tarball.

=head1 Author

Alexis Sukrieh, C<< <sukria@sukria.net> >>
